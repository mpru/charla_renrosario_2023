[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cómo crear paquetes multilingües + Qué es ROpenSci",
    "section": "",
    "text": "En este encuentro de R en Rosario vamos a repasar qué pasos hay que seguir para crear un paquete y pensar algunas estrategias para que pueda ser usado en más de un idioma. Además, vamos a conocer a qué se dedica la organización ROpenSci y cómo podemos ser parte.\nEn la sección Preparación y materiales vas a encontrar los materiales necesarios para seguir los ejemplos.\n\n\n\n\n\n\nPresentador\nMarcos Prunello: Soy Licenciado en Estadística (UNR) y MSc en Biomedical Informatics (Stanford University). Me dedico a la vida universitaria, trabajando en cuestiones de Estadística y Ciencia de Datos en la FCEyE-UNR y Universidad Austral.\n\n\nLicencia\n Los materiales de esta charla están bajo la licencia Creative Commons Attribution-ShareAlike 4.0 International License."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "crear_paquetes.html",
    "href": "crear_paquetes.html",
    "title": "Creación de paquetes",
    "section": "",
    "text": "Esta guía cubre de forma más extensa los pasos de la creación de un paquete. Podés ver los materiales consultados al final de la página."
  },
  {
    "objectID": "crear_paquetes.html#preparativos",
    "href": "crear_paquetes.html#preparativos",
    "title": "Creación de paquetes",
    "section": "Preparativos",
    "text": "Preparativos\n\nPara poder seguir este tutorial, necesitás tener instalados los siguientes paquetes:\n\ninstall.packages(c(\"devtools\", \"usethis\", \"roxygen2\", \"dplyr\",\n                   \"testthat\", \"knitr\", \"available\"))\n\nAdemás, si usás Windows necesitás descargar el programa Rtools desde este link e instalarlo en tu computadora."
  },
  {
    "objectID": "crear_paquetes.html#por-qué-podríamos-considerar-crear-un-paquete",
    "href": "crear_paquetes.html#por-qué-podríamos-considerar-crear-un-paquete",
    "title": "Creación de paquetes",
    "section": "¿Por qué podríamos considerar crear un paquete?",
    "text": "¿Por qué podríamos considerar crear un paquete?\nNos da la oportunidad de:\n\nCompartir de forma sencilla y rápida el trabajo que realizamos y que muchas veces queda sin difusión, aportándole visibilidad. Esto incluye:\n\nMetodología nueva o código desarrollado en tesinas y tesis.\nCódigo para realizar tareas dentro del equipo de trabajo.\nCódigo que acompañe a los trabajos de investigación publicados.\nMaterial didáctico creado para dar clases o estudiar.\n\nOrganizar el trabajo dentro de los equipos de trabajo o de investigación. Un paquete puede ser una buena manera de cerrar una tesina o publicación, dejando código organizado, entendible y que pueda servir de punto de partida para otros estudiantes o para nosotros cuando continuemos en el futuro. De la misma forma, encerrar en un paquete rutinas de trabajo puede servir para estandarizar protocolos de trabajo en empresas.\nRealizar nuevas publicaciones. Los paquetes se pueden publicar en revistas como Journal of Statistical Software o Bioconductor. También sirven como antecedentes en los sistemas nacionales de registro de actividades académicas (CVAR, Sigeva, etc.)\nDarnos a conocer en el ambiente regional de la Estadística y “ciencia de datos”, ya que implica una presencia en la virtualidad, teniendo hoy en día muchos intercambios que se originan a partir de la difusión en redes sociales."
  },
  {
    "objectID": "crear_paquetes.html#repositorios-de-paquetes",
    "href": "crear_paquetes.html#repositorios-de-paquetes",
    "title": "Creación de paquetes",
    "section": "Repositorios de paquetes",
    "text": "Repositorios de paquetes\n\nUn repositorio es un lugar en el cual se alojan los paquetes para que la gente pueda acceder a ellos e instalarlos en sus propios sistemas.\nLos cuatro repositorios más populares son:\n\nCRAN (Comprehensive R Archive Network): es el repositorio oficial compuesto por una serie de servidores coordinados por la R Foundation. Para que un paquete pueda ser publicado acá tiene que pasar varios testeos y regirse según la política de la organización.\nBioconductor: es un repositorio específico para paquetes relacionados a la Bioinformática y al análisis de datos biológicos. Tiene un sistema propio de revisión.\nrOpenSci: es una organización que promueve las buenas prácticas en la ciencia de datos y la investigación reproducible y ha creado su propio repositorio de paquetes.\nGitHub: no es exclusivo de R, pero es un repositorio que aloja muchísimos proyectos de código abierto y que provee un contexto muy bueno para el desarrollo colaborativo de software al estar asociado al sistema de control de versiones git. Suele ser la plataforma de lanzamiento de paquetes que finalmente se publican en otros repositorios. No tiene un proceso de revisión."
  },
  {
    "objectID": "crear_paquetes.html#a-ver-qué-sabemos-sobre-paquetes",
    "href": "crear_paquetes.html#a-ver-qué-sabemos-sobre-paquetes",
    "title": "Creación de paquetes",
    "section": "A ver qué sabemos sobre paquetes…",
    "text": "A ver qué sabemos sobre paquetes…\nTratá de responder las siguientes preguntas:\n\n¿Cómo se instala un paquete desde CRAN?\n¿Cómo se instala un paquete desde GitHub?\n¿Qué sucede en la computadora cuando instalamos un paquete?\n¿Qué es una librería (library)?\n¿Dónde está la librería que se usa por default en tu computadora? ¿En qué librerías se buscan los paquetes cuando los querés cargar?\n¿Cuántos paquetes tenés instalados?\n¿Cómo adjuntás un paquete? ¿Qué significa esto?\n\nRespuestas:\n\ninstall.packages(\"nombre_paquete\")\ndevtools::install_github(\"nombre_usuario/nombre_paquete\")\nInstalar un paquete es descargar ciertos archivos a una carpeta en particular de la computadora.\nUna librería es una colección de paquetes, es decir, es la ubicación (carpeta) donde se alojan los paquetes. Podemos tener múltiples librerías en el disco duro. Una library es como una biblioteca y un package vendría a ser uno de sus libros.\n\n\n\n.libPaths()\n\"/home/marcos/R/x86_64-pc-linux-gnu-library/3.6\" \"/usr/lib/R/library\"\n\n\nVemos los paquetes instalados con:\n\n\nnrow(installed.packages())\n\n[1] 648\n\n\nLa instalación de R trae 14 paquetes base y 15 recomendados. Al resto, los vamos instalando nosotros:\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\ninstalled.packages() |>\n  as_tibble() |>\n  filter(Priority %in% c(\"base\", \"recommended\")) |>\n  select(Package)\n\n# A tibble: 29 × 1\n   Package  \n   <chr>    \n 1 base     \n 2 boot     \n 3 class    \n 4 cluster  \n 5 codetools\n 6 compiler \n 7 datasets \n 8 foreign  \n 9 graphics \n10 grDevices\n# ℹ 19 more rows\n\n\n\nPara adjuntar (attach) un paquete se usa la función library(), por ejemplo, library(ggplot2) (tal vez estemos más acostumbrados a decir cargar un paquete, pero en la jerga de R load es en realidad otra cosa)\nCuando adjuntamos un paquete, hacemos que sus funciones puedan usarse. Recordando que una library es como una biblioteca y un package como uno de sus libros, se puede decir que usamos la función library() para sacar un libro de la biblioteca.\nTécnicamente, adjuntar un paquete significa poner todas sus funciones en el camino de búsqueda de R (search path). Para hacer uso de una función, R primero necesita encontrarla, y para esto primero busca en el ambiente global. Si no la encuentra, empieza a buscar en orden en una serie de lugares definidos en el search path, recorriendo todos los paquetes que se habían adjuntado con library(). Podemos ver el listado de los lugares donde R va a buscar con:\n\n\n# Vemos los paquetes adjuntados\nsearch()\n\n [1] \".GlobalEnv\"        \"package:dplyr\"     \"tools:quarto\"     \n [4] \"tools:quarto\"      \"package:stats\"     \"package:graphics\" \n [7] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n[10] \"package:methods\"   \"Autoloads\"         \"package:base\"     \n\n# Vemos de qué librerías provienen\nsearchpaths()\n\n [1] \".GlobalEnv\"                                          \n [2] \"/home/marcos/R/x86_64-pc-linux-gnu-library/4.2/dplyr\"\n [3] \"tools:quarto\"                                        \n [4] \"tools:quarto\"                                        \n [5] \"/usr/lib/R/library/stats\"                            \n [6] \"/usr/lib/R/library/graphics\"                         \n [7] \"/usr/lib/R/library/grDevices\"                        \n [8] \"/usr/lib/R/library/utils\"                            \n [9] \"/usr/lib/R/library/datasets\"                         \n[10] \"/usr/lib/R/library/methods\"                          \n[11] \"Autoloads\"                                           \n[12] \"/usr/lib/R/library/base\"                             \n\n\nHay 7 paquetes que siempre están adjuntados: rstats, graphics, methods, base, datasets, utils y grDevices."
  },
  {
    "objectID": "crear_paquetes.html#la-estructura-de-un-paquete",
    "href": "crear_paquetes.html#la-estructura-de-un-paquete",
    "title": "Creación de paquetes",
    "section": "La estructura de un paquete",
    "text": "La estructura de un paquete\n\nCrear un paquete no es más que seguir ciertas convenciones para organizar un conjunto de carpetas y archivos.\nUn paquete es una carpeta de nuestra computadora que tiene ciertos elementos obligatorios y algunos otros opcionales.\n\n\n\n\nEjemplo de la apariencia de un paquete de R con los elementos más comunes.\n\n\nElementos obligatorios:\n\nArchivo Description: describe el contenido del paquete y establece cómo el paquete se va a relacionar con otros.\nCarpeta R: contiene el o los archivos de código de R con las funciones del paquete.\nCarpeta man: contiene archivos con la documentación del paquete, funciones y datasets.\nArchivo NAMESPACE: declara qué funciones nuestro paquete pone a disposición de los usuarios y de qué funciones de otros paquetes hace uso el nuestro, es decir, organiza las cosas para que R pueda encontrar todo lo que necesita cuando usa nuestro paquete.\n\nElementos opcionales:\n\nCarpeta data: contiene objetos de R (por ejemplo, .Rdata) que contienen datos.\nCarpeta vignettes: contiene los tutoriales que muestran ejemplos de uso del paquete, generalmente escritos en Rmarkdown.\nArchivo NEWS: lleva el registro de los cambios implementados en las sucesivas versiones de un paquete.\nArchivo LICENSE: especifica los detalles de la licencia bajo la cual se distribuye el paquete. Es obligatorio bajo ciertos tipos de licencias (como la MIT).\nArchivo .Rbuildignore: lista los archivos y directorios que no deben ser incluidos a la hora de construir el paquete.\nCarpeta tests: incluye código para someter al paquete a diversos controles.\nCarpeta src: incluye archivos fuente para código compilado en otro lenguaje, por ejemplo, C++.\nCarpeta inst: para guardar algunas otras cosas."
  },
  {
    "objectID": "crear_paquetes.html#elegir-el-nombre",
    "href": "crear_paquetes.html#elegir-el-nombre",
    "title": "Creación de paquetes",
    "section": "Elegir el nombre",
    "text": "Elegir el nombre\n\nEl primer paso para crear un paquete tal vez sea uno de los más complicados: elegir un nombre.\nEsto puede tener poca importancia si estamos haciendo un paquete de uso personal, pero si pensamos en compartirlo, entonces hay que dedicarle algo de tiempo.\nLas reglas para elegir un nombre son:\n\nSólo puede contener letras, números o puntos.\nTener al menos dos caracteres.\nEmpezar con una letra y no terminar con punto.\n\nAlgunas sugerencias incluyen elegir un nombre que sea fácil de googlear y de recordar, que tenga todas mayúsculas o minúsculas, que tal vez surja de agregarle una R a una palabra que existe para generar un nombre único.\nPara practicar vamos a crear un paquete con una única función que determina si un año es o no bisiesto, por eso lo vamos a llamar bisiestos (no, no se nos ocurrió otro nombre más original!).\nCon el paquete available se puede chequear si este nombre está disponible en los repositorios mencionados anteriormente.\nAdemás, este paquete nos avisa si el nombre elegido tiene algún significado especial del cual podemos no estar al tanto (revisa las webs de Wikipedia, Wiktionary y Urban Dictionary)\n\nlibrary(available)\navailable(\"bisiestos\")\n\n\n\n\n\nChequear disponibilidad del nombre."
  },
  {
    "objectID": "crear_paquetes.html#crear-el-paquete",
    "href": "crear_paquetes.html#crear-el-paquete",
    "title": "Creación de paquetes",
    "section": "Crear el paquete",
    "text": "Crear el paquete\n\n¡Basta de cháchara y manos a la masa! Vamos a crear nuestro paquete.\nPara esto, vamos a recibir la ayuda de los paquetes devtools y usethis, que incluyen un montón de funciones para simplificar la tarea de la creación de un nuevo paquete (alcanza con adjuntar devtools porque este a su vez adjunta a usethis).\n\n\n\n\nPaquetes devtools y usethis.\n\n\n\nlibrary(devtools)\n\n\nLa forma más fácil de crear un paquete es haciendo uso de la función create_package(\"nombre_paquete\"), que va a generar una carpeta con el nombre provisto en el directorio de trabajo actual. Si queremos que se genere en otro lugar, debemos indicarle la ruta hacia el mismo, por ejemplo: create_package(\"C:/Users/Documentos/nombre_paquete\"):\n\n\ncreate_package(\"bisiestos\")\n\n✓ Creating '/home/marcos/Documents/Clases/bisiestos/'\n✓ Setting active project to '/home/marcos/Documents/Clases/bisiestos'\n✓ Creating 'R/'\n✓ Writing 'DESCRIPTION'\nPackage: bisiestos\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R (parsed):\n    * First Last <first.last@example.com> [aut, cre] (YOUR-ORCID-ID)\nDescription: What the package does (one paragraph).\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to\n    pick a license\nEncoding: UTF-8\nLazyData: true\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.1.1\n✓ Writing 'NAMESPACE'\n✓ Writing 'bisiestos.Rproj'\n✓ Adding '^bisiestos\\\\.Rproj$' to '.Rbuildignore'\n✓ Adding '.Rproj.user' to '.gitignore'\n✓ Adding '^\\\\.Rproj\\\\.user$' to '.Rbuildignore'\n✓ Opening '/home/marcos/Documents/Clases/bisiestos/' in new RStudio session\n✓ Setting active project to '<no active project>'\n\nAdemás de crear esta carpeta, se crea un proyecto de RStudio alojado allí, con el mismo nombre.\nSi estamos trabajando en RStudio, luego de correr create_package() se abre dicho proyecto en una nueva sesión.\nEsto es útil, porque al reconocer que nuestro proyecto trata del desarrollo de un paquete, RStudio provee algunas opciones especiales, como la pestaña Build en el panel de arriba a la derecha.\nAsegurate de cargar los paquetes devtools y usethis en esta nueva sesión.\nPodemos ver la existencia de la nueva carpeta bisiestos con los archivos recientemente creados en el panel Files:\n\n\n\n\nResultado de la creación del paquete.\n\n\nComentarios adicionales: hay algunos componentes que se crean en esta carpeta y que, si bien podemos ignorar, acá comentamos de qué se tratan:\n\nbisiestos.Rproj: guarda las opciones de configuración elegidas para el proyecto y sirve para abrirlo directamente desde el explorador de archivos de la compu.\n.Rproj.user: carpeta oculta usada internamente por RStudio para guardar archivos temporarios.\n.gitignore: archivo oculto que lista todos los archivos de R y RStudio que no deberían ser rastreados por el sistema de control de versiones, si el mismo fuese utilizado. No hace nada si no usamos git."
  },
  {
    "objectID": "crear_paquetes.html#crear-los-archivos-de-código",
    "href": "crear_paquetes.html#crear-los-archivos-de-código",
    "title": "Creación de paquetes",
    "section": "Crear los archivos de código",
    "text": "Crear los archivos de código\n\nPara definir una función para nuestro paquete, abrimos un script de R y la escribimos como haríamos usualmente, con la excepción de que tenemos que tener en cuenta estas dos cosas:\n\nHay que guardar el script en la carpeta R.\nSi usamos funciones de otros paquetes, las invocamos escribiendo paquete::funcion(), por ejemplo dplyr::mutate() (se podría evitar, pero es una buena práctica).\n\nNi siquiera tenemos que molestarnos por crear el archivo en la carpeta correcta, eso se hace automáticamente con la función use_r(), en la cual especificamos el nombre del archivo de código:\n\n\nuse_r(\"funciones\")\n\n● Modify 'R/funciones.R'\n\nuse_r() entonces se encarga de agregar un archivo .R en la carpeta R del paquete, para que nosotros escribamos nuestras funciones allí.\nVamos a agregar el código para la creación de una función que nos determina si un año provisto es bisiesto o no.\nPara repasar acerca de la escritura de funciones, podés volver a ver el material de nuestra clase sobre este tema o visitar estos capítulos de los libros R for Data Science o Advanced R.\nCopiá y guardá esto en el archivo recién creado:\n\n\nes_bisiesto <- function(x = as.integer(format(Sys.Date(), \"%Y\"))) {\n\n    # Chequear argumento\n    stopifnot(is.numeric(x))\n    x <- as.integer(x)\n\n    # Determinar si es bisiesto\n    rtdo <- ((x %% 4 == 0) & (x %% 100 != 0)) | (x %% 400 == 0)\n    names(rtdo) <- x\n\n    # Devolver años bisiestos\n    return(rtdo)\n}\n\n\n\n\nEscritura del código.\n\n\n\nUn paquete siempre tiene funciones que están pensadas para ser utilizadas por los usuarios luego de lo carguen con el famosos library(...), es decir, son funciones que se deben exportar para que estén disponibles. Sin embargo, hay veces que definimos funciones auxiliares, que sólo son de uso interno del paquete, y que no es necesario que estén al alcance de los usuarios del paquete.\nPara avisar cuáles son las funciones que se deben exportar hay que editar el archivo NAMESPACE, que inicialmente luce así:\n\n\n\n\nArchivo NAMESPACE.\n\n\n\nMás adelante vamos a hablar más sobre este archivo y, si bien hay una sugerencia que nos dice que no lo editemos a mano, por ahora no le vamos a hacer caso y vamos a agregar la siguiente línea para establecer que la función es_bisiesto() tiene que estar disponible para su uso luego de que alguien corra library(bisiestos):\n\nexport(es_bisiesto)\n\n\n\nArchivo NAMESPACE.\n\n\n\nSeguramente nos interese ir probando nuestra función a medida que la estamos desarrollando o cuando creemos que la hemos finalizado.\nEs decir, nos interesa tenerla disponible en nuestro ambiente de trabajo para poder usarla.\nLa idea natural sería correr el código anterior, o hacer source(R/funciones.R).\nSin embargo, devtools nos provee otro enfoque más adecuado para cargar todo el contenido del paquete que estamos desarrollando.\nSe trata de la función load_all(), o su atajo ctrl + shift + l.\n\n\nload_all()\n\nLoading bisiestos\n\nComo resultado, todas las funciones definidas están listas para ser usadas (aunque no las veamos en el global environment):\n\n\nes_bisiesto(2019)\n\n 2019 \nFALSE \n\nes_bisiesto(2020)\n\n2020 \nTRUE \n\nrtdo <- es_bisiesto(2020:2025)\nrtdo\n\n 2020  2021  2022  2023  2024  2025 \n TRUE FALSE FALSE FALSE  TRUE FALSE \n\nes_bisiesto(0)\n\n   0 \nTRUE \n\nes_bisiesto(-1:-5)\n\n   -1    -2    -3    -4    -5 \nFALSE FALSE FALSE  TRUE FALSE \n\n\n\nload_all() simula el proceso de construir, instalar y adjuntar el paquete.\nA medida que el mismo va creciendo, con funciones internas y otras que se exportan, con funciones que se llaman unas a otras, con funciones que dependen de otros paquetes, probar nuestras funciones de esta forma nos da una idea más certera de cómo está quedando todo en el paquete.\nEntonces, se puede definir el siguiente flujo de trabajo (workflow) para la escritura del código:\n\n\n\n\nFlujo de trabajo.\n\n\nComentarios adicionales:\n\nPodés agregar tantos archivos de código como desees en la carpeta R.\nGeneralmente, hay que pensar y diseñar un poco cómo vamos a guardar todo el código.\nSe sugiere agrupar funciones que tengan algo en común en un mismo archivo.\nUn archivo para cada función o todas las funciones en un mismo archivo son los puntos extremos que, generalmente, deberían evitarse."
  },
  {
    "objectID": "crear_paquetes.html#instalar-el-paquete",
    "href": "crear_paquetes.html#instalar-el-paquete",
    "title": "Creación de paquetes",
    "section": "Instalar el paquete",
    "text": "Instalar el paquete\n\nAunque no lo creas, ¡ya hemos terminado la primera versión de nuestro paquete y estamos en condiciones de instalarlo!\nEsto lo podemos hacer de varias formas:\n\nCorriendo install()\nUsando el atajo ctrl + shift + b\nHaciendo clic en Install and restart de la pestaña Build.\n\n\n\ninstall()\n\n==> R CMD INSTALL --no-multiarch --with-keep.source bisiestos\n\n* installing to library ‘/home/marcos/R/x86_64-pc-linux-gnu-library/3.6’\n* installing *source* package ‘bisiestos’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\nNo man pages found in package  ‘bisiestos’ \n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (bisiestos)\n\n\n\nResultado de la instalación.\n\n\n\nEste proceso finaliza con la carga del paquete a través de library(bisiestos), indicando que está listo para ser usado, como cualquier otro paquete, no solamente ahora, si no que ya podemos cerrar R y volver a emplearlo en cualquier otro momento.\n¡Felicitaciones! ¡Acabás de crear tu primer paquete de R! Si tenés ganas podés iniciar una nueva sesión, correr library(bisiestos) y usar la función es_bisiesto().\n\nComentario adicionales:\n\nAhora ya puedo ver mi nuevo paquete en la library que usa mi compu. Sin embargo, si chusmeo esta carpeta, no tiene exactamente el mismo aspecto que la carpeta en la cual estoy desarrollando el paquete. ¿Por qué?\nRespuesta: porque al desarrollar un paquete estamos interactuando con su versión source (source package), la cual constituye uno de los 5 estados en los cuales podemos encontrar un paquete:\n\npaquete source: es una carpeta con archivos guardados respetando cierta estructura (la carpeta que hemos creado con create_package())\npaquete bundled: es un source paquete que fue comprimido a un único archivo (tiene extensión .tar.gz), es independiente del sistema operativo que se use y resulta cómodo para enviar el paquete de un lado a otro. Si se lo descomprime luce casi igual que un source package.\npaquete binary: también es un paquete comprimido a un único archivo, pero depende de cada sistema operativo, es lo que necesita alguien que quiera instalar un paquete pero no tenga herramientas para el desarrollo de los mismos que le permitan instalarlo (como Rtools). Hay binary packages para Windows y para macOS (Linux siempre instala desde el bundled). Si se lo descomprime, luce bastante distinto al source o al bundled package.\npaquete instalado: un bundled o binary package que fue descomprimido en una librería.\npaquete en memoria: paquete que fue adjuntado en la sesión de R mediante library() y forma parte del searchpath."
  },
  {
    "objectID": "crear_paquetes.html#escribir-la-documentación",
    "href": "crear_paquetes.html#escribir-la-documentación",
    "title": "Creación de paquetes",
    "section": "Escribir la documentación",
    "text": "Escribir la documentación\n\nA la hora de armar un paquete (y de crear cualquier función en general) es importante dedicarle unos minutos a la creación de la documentación, es decir, describir cómo se usa cada función, para qué sirven los argumentos, aclarar qué tipo de resultado devuelve, proveer ejemplos para el uso, etc.\nEsto es particularmente importante si pretendemos compartir el paquete con otras personas, pero también nos ayuda a nosotros para que no nos olvidamos en el futuro qué quisimos hacer y evitemos perder tiempo tratando de descifrar cómo andan las funciones que escribimos en el pasado.\nEspecíficamente, documentar el paquete y sus funciones significa crear todas las páginas que vemos cuando exploramos el manual de ayuda.\nPor suerte, armarlo no es tan complicado como uno lo podría imaginar, ya que contamos con la ayuda del paquete roxygen2 (lo difícil es escribir ayuda que sea entendible y útil para otros…).\nEste paquete provee pautas para escribir comentarios con un formato especial que incluyan toda la información requerida justo antes de la definición de la función.\nEsto hace que tomemos la costumbre de escribir la documentación al mismo tiempo que creamos la función, sin que se vuelva una carga pesada para más adelante.\nDe la siguiente forma podemos documentar nuestra función es_bisiesto():\n\n\n#' La función es_bisiesto\n#' \n#' Esta función analiza si el año o los años provistos son bisiestos o no. Los\n#' años bisiestos ocurren cada 4 años, excepto los terminados en 00, los cuales\n#' son bisiestos sólo si son divisibles por 400. Es decir, los años como 1600,\n#' 1700, 1800 son bisiestos si son divisibles por 400. Por ejemplo, el año 1900\n#' no fue bisiesto a pesar de ser divisible por 4, pero el año 2000 sí lo fue\n#' por ser divisible por 400. Entonces, para que un año dado sea bisiesto, se\n#' debe cumplir una de las siguientes condiciones: el año es divisible por 4\n#' pero no divisible por 100, o el año es divisible por 400.\n#'\n#' @param x vector numérico de largo mayor o igual a 1 con los años a evaluar.\n#'   Por default, toma el año actual.\n#'\n#' @return vector lógico de igual largo que `x` y nombrado con los elementos de\n#' `x`, con valor `TRUE` en cada si el correspondiente año indicado en `x` es\n#' bisiesto y `FALSE` en caso contrario.\n#' \n#' @details Si `x` contiene valores no enteros, se toma su parte entera. Esta\n#'   función sirve para los años antes de Cristo, si se los considera bajo la\n#'   numeración astronómica de los años (incluye un año 0 y luego cuenta en\n#'   negativo, por ejemplo, el año 0 es 1 AC o el año -1 es 2 AC.).\n#'   \n#' @seealso \\url{https://es.wikipedia.org/wiki/Año_bisiesto}\n#'\n#' @examples\n#' es_bisiesto(2019)\n#' es_bisiesto(2020)\n#' rtdo <- es_bisiesto(2020:2025)\n#' rtdo\n#' es_bisiesto(0)\n#' es_bisiesto(-1:-5)\n#' \n#' @export\n\n\nAlgunas pautas generales para entender la estructura de los comentarios Roxygen:\n\nCada línea comienza con #'.\nLa primera línea es el título de la función (no tiene que coincidir con su nombre).\nA continuación sigue un párrafo con la descripción de la función.\nLuego se especifican los distintos campos de la documentación, haciendo uso de etiquetas (tags) que comienzan con @.\nAlgunas de las etiquetas más importantes a incluir son:\n\n@param: se detalla para qué sirve cada parámetro de la función.\n@inheritParam: si se trata del mismo parámetro usado en otra función, donde ya lo documenté, puedo usar esto para “heredarlo” y no tener que repetirlo.\n@return: para explicar qué objeto devuelve la función.\n@details: para agregar cualquier aclaración que se considere necesaria.\n@examples: para incluir ejemplos de uso de la función.\n@export: para indicar que esta función tiene que estar disponible cuando alguien cargue el paquete con library(). No es necesario exportar funciones auxiliares de utilidad interna.\n\n\nPor suerte ni tenemos que escribir toda esta estructura. Si estando parados sobre la definición de la función vamos al menú Code y elegimos Insert Roxygen Skeleton, veremos cómo automáticamente se monta un esqueleto para que completemos donde corresponda. Probalo ahora.\nUna vez que hemos documentado la o las funciones, se tienen que generar los archivos .Rd que compondrán el manual y que deben ir guardados en la carpeta man.\nAdemás, hay que modificar el archivo NAMESPACE del paquete para especificar qué funciones van a estar disponibles para los usuarios, según lo que hayamos indicado con las etiquetas @export.\nOtra vez, por suerte todo esto se puede hacer automáticamente, al correr la función devtools::document() o su atajo ctrl + shift + d:\n\n\ndocument()\n\n==> devtools::document(roclets=c('rd', 'collate', 'namespace'))\n\nUpdating bisiestos documentation\nUpdating roxygen version in /home/marcos/GitProjects/bisiestos/DESCRIPTION\nWriting NAMESPACE\nLoading bisiestos\nDocumentation completed\n\n\n\nResultado de correr document().\n\n\n\nImportante: la función document() se encarga de editar automáticamente el archivo NAMESPACE, de modo que no necesitamos hacerlo a mano (por eso la recomendación de no hacerlo, sería muy fácil cometer algún error). Antes lo hicimos para poder probar el paquete enseguidita y ver que todo andaba, pero es mejor que primero escribas la documentación, incluyendo la etiqueta @export, luego ejecutes document() y automáticamente se escriba el archivo NAMESPACE solito y sin errores.\nLas funciones que no se exportan, son de uso interno del paquete y son todas aquellas que no tienen la etiqueta @export (y que por eso nunca van a figurar en el NAMESPACE. Cuando alguien cargue nuestro paquete con library(), no las va a poder usar (o sí, si sabe el secreto de poner tres veces, dos puntos: nombrepaq:::funcion_interna()).\nEntonces, tenemos la siguiente clasificación para las funciones que escribimos:\n\n\n\n\n\n\n\nFunción interna\nFunción externa\n\n\n\n\nPara uso exclusivo dentro del paquete\nPara que la usen los demás\n\n\nLa documentación es opcional\nLa documentación es obligatoria\n\n\nPodemos modificarla todo lo que queramos\nModificarla podría romper el código de los usuarios del paquete\n\n\n\nAhora podemos volver a instalar el paquete con ctrl + shift + b y pispear cómo se ve la ayuda que creamos:\n\n\n?es_bisiesto\n\n\n\n\nPágina de ayuda creada.\n\n\nComentarios adicionales:\n\nNosotros escribimos los comentarios, roxygen2 se encarga de crear los archivos .Rd (podemos ignorarlos) y finalmente R cuando construye el paquete escribe las correspondientes páginas en formato html.\nPodríamos escribir “a mano” los .Rd e independizarnos de roxygen2, así como editar a mano el NAMESPACE, pero es recomendable no tocarlos para no hacer lío y dejar que se encargue la función document().\nEs una buena práctica no escribir líneas muy largas de comentarios, sino que lo ideal es que se pueda leer sin tener que mover las barras desplazadoras del editor de código. Suele recomendarse que no se escriban más de 80 caracteres por línea. Para que podamos escribir como queramos sin preocuparnos por esto, podemos seleccionar el texto escrito y hacer ctrl + shift + / y automáticamente se reconfigurará para seguir esta recomendación.\nSi se incluyen datasets en el paquete, también se los debe documentar, para lo cual hay que agregar comentarios roxygen2 en algún script de la carpeta R. Podemos crear un script por dataset a incluir, un único script para poner la documentación de todos los datasets juntos, o agregarla en otro script ya existente (aunque esto sería más desprolijo).\nA continuación se muestra cómo está escrita la documentación en roxygen2 para el dataset diamonds del paquete ggplot2:\n\n#' Prices of 50,000 round cut diamonds\n#'\n#' A dataset containing the prices and other attributes of almost 54,000\n#'  diamonds. The variables are as follows:\n#'\n#' \\itemize{\n#'   \\item price. price in US dollars (\\$326--\\$18,823)\n#'   \\item carat. weight of the diamond (0.2--5.01)\n#'   \\item cut. quality of the cut (Fair, Good, Very Good, Premium, Ideal)\n#'   \\item colour. diamond colour, from J (worst) to D (best)\n#'   \\item clarity. a measurement of how clear the diamond is (I1 (worst), SI1, SI2, VS1, VS2, VVS1, VVS2, IF (best))\n#'   \\item x. length in mm (0--10.74)\n#'   \\item y. width in mm (0--58.9)\n#'   \\item z. depth in mm (0--31.8)\n#'   \\item depth. total depth percentage = z / mean(x, y) = 2 * z / (x + y) (43--79)\n#'   \\item table. width of top of diamond relative to widest point (43--95)\n#' }\n#'\n#' @docType data\n#' @keywords datasets\n#' @usage data(diamonds)\n#' @format A data frame with 53940 rows and 10 variables\n\"diamonds\""
  },
  {
    "objectID": "crear_paquetes.html#editar-el-archivo-description",
    "href": "crear_paquetes.html#editar-el-archivo-description",
    "title": "Creación de paquetes",
    "section": "Editar el archivo DESCRIPTION",
    "text": "Editar el archivo DESCRIPTION\n\nEl archivo DESCRIPTION provee toda la metadata sobre el paquete que estamos creando.\nAsí se ve cómo es la primera versión del mismo, creada automáticamente por la función create_package():\n\n\n\n\nArchivo DESCRIPTION.\n\n\n\nEn este archivo hay algunos campos que tienen que estar presentes de forma obligatoria y otros que son opcionales. Acá mencionamos a los más importantes:\n\nElementos obligatorios:\n\nPackage: nombre del paquete\nTitle: título del paquete (hasta 65 caracteres, Escrito De Esta Forma).\nVersion: número de la versión actual del paquete (por ejemplo, 0.2.1)\nAuthor, Maintainer o Authors@R: quiénes han participado en el paquete.\nDescription: un párrafo que describa el paquete.\nLicense: nombre de la licencia bajo la cual se distribuye el paquete.\n\nElementos no obligatorios:\n\nDate: fecha de publicación de esta versión del paquete.\nImports, Depends, Suggests: ver detalles en la siguiente sección.\nURL: dirección de la página web del paquete.\nBugReports: dirección donde los usuarios puedan enviar avisos con los problemas que encuentren (muchas veces la página de Issues de GitHub).\n\n\nEn cuanto a los autores, una misma persona puede cumplir varios roles y puede haber varias personas en el mismo rol.\nLos roles de uso más común son:\n\nAutor (author): autor del paquete, se indica con la etiqueta aut\nMantenedor (maintainer): persona a cargo de arreglar los problemas que puedan surgir en CRAN, recibe notificaciones sobre errores por parte de los usuarios, etc. Sólo puede haber un maintainer. Se indica con la etiqueta cre.\nContribuyente (contributor): alguien que hizo un aporte menor, se indica con ctb.\n\nDespués de algunos agregados, nuestro DESCRIPTION luce así:\nPackage: bisiestos\nTitle: Determinación de años bisiestos\nVersion: 0.0.0.9000\nAuthors@R: \n    c(person(given = \"Marcos\",\n             family = \"Prunello\",\n             role = c(\"aut\", \"cre\"),\n             email = \"marcosprunello@gmail.com\"),\n      person(given = \"Diego\",\n             family = \"Marfetán Molina\",\n             role = \"aut\",\n             email = \"diego.marfetan@gmail.com\"))\nDescription: Este paquete permite determinar si un año es bisiesto o no, \n      proveyendo una solución definitiva a un problema de tediosa solución.\nLicense: What license it uses\nEncoding: UTF-8\nLazyData: true\nRoxygenNote: 7.0.2"
  },
  {
    "objectID": "crear_paquetes.html#entender-las-dependencias",
    "href": "crear_paquetes.html#entender-las-dependencias",
    "title": "Creación de paquetes",
    "section": "Entender las dependencias",
    "text": "Entender las dependencias\n\nEs muy común que nuestras funciones necesiten hacer uso de otras que pertenecen a otros paquetes.\nCuando estamos haciendo algún análisis, cargamos esos otros paquetes con library(), pero dentro del código de nuestro paquete, nunca debemos incluir una llamada a library().\nSi correr ciertas funciones de nuestro paquete modifica el search path del usuario, podríamos estar produciendo efectos colaterales no deseados.\nEn su lugar, necesitamos avisar qué cosas necesita nuestro paquete a través de los campos Imports, Depends y Suggests del archivo DESCRIPTION.\nSi en mi DESCRIPTION pongo:\nImports:\n    lubridate (>= 1.0.0),\n    purrr\nDepends: \n    R (>= 3.6)\nSuggests:\n    ggplot2\nvoy estar diciendo que mi paquete necesita sí o sí de los paquetes lubridate (versión igual o superior a la 1.0.0) y purrr (sin restricciones sobre la versión). También estoy diciendo que sólo se puede usar en versiones de R iguales o superiores a la 3.6 y que podría hacer uso del paquete ggplot2 para, por ejemplo, correr ejemplos o ver las viñetas, aunque el mismo no es indispensable.\nLos tres tipos de dependencias, entonces, son:\n\nImports: nuestro paquete lo requiere, se instala automáticamente.\nSuggests: es opcional (se usa sólo para ejemplos o en la viñeta), no se instala automáticamente.\nDepends: también se pueden poner paquetes acá, pero es una práctica que ya no se acostumbra. Hay una diferencia muy sutil entre poner un paquete en Imports o en Depends, que no es importante en la mayoría de los casos. Por eso, sólo se usa para indicar la versión de R (si es que se usa).\n\nNo hace falta que editemos DESCRIPTION a mano, la función usethis::use_package() lo hace por nosotros:\n\n# Agregar en Imports\nusethis::use_package(\"purrr\")\n# Agregar en Suggests\nusethis::use_package(\"ggplot2\", type = \"suggests\")\n\n\n\n\nArchivo DESCRIPTION modificado.\n\n\nUna vez que hemos agregado los paquetes que necesitamos en DESCRIPTION, debemos acceder a sus funciones con el operador :: cada vez que las necesitemos en nuestro código. Por ejemplo, hacemos uso de la función map() del paquete purrr con:\n\nmi_funcion <- function() {\n  ...\n  x <- purrr::map(1:10, rnorm, n = 5)\n  ...\n}\n\nEs posible que haya una función de otro paquete que usamos demasiado y nos moleste tener que escribir siempre el formato nombrepaq::funcion_importada().\nEn ese caso podemos agregar el siguiente comentario roxygen en cualquier parte de nuestra documentación (o tal vez en un script especial para esto):\n\n#' @importFrom purrr map\n\nPara luego sencillamente usarla haciendo:\n\nmi_funcion <- function() {\n  ...\n  x <- map(1:10, rnorm, n = 5)\n  ...\n}\n\nSi usamos la etiqueta @importFrom, al correr document() se modifica el archivo NAMESPACE, importando la función pedida a nuestro espacio de nombres, de manera que R la va a poder encontrar sin problemas cuando la necesite.\nPodríamos importar todas las funciones de un paquete y listo, con:\n\n#' @import purrr\n\nSin embargo esto es peligroso, ya que no sabemos si en un futuro habrá nuevas funciones en el paquete purrr cuyos nombres introduzcan algún tipo de conflicto por ser iguales a los nombres de nuestras funciones o las de otros paquetes que necesitamos usar.\nPara usar uno de los paquetes de Suggests, deberíamos primero chequear si la persona lo tiene instalado o no, posiblemente con algo como:\n\nif (!requireNamespace(\"nombrepaq\", quietly = TRUE)){\n  warning(\"nombrepaq debe estar instalado para poder usar esta función,\n          se devuelve NULL.\")\n  return(NULL)\n}\n\nResumiendo, para poder usar otro paquete hay que modificar DESCRIPTION sí o sí, y opcionalmente también NAMESPACE:\n\n\n\n\n\n\n\n\n\nArchivo:\nDESCRIPTION\nNAMESPACE\n\n\n\n\nQué logra:\nQue el paquete esté disponible\nQue una función esté disponible\n\n\nModificación:\nObligatoria\nOpcional (se puede usar :: en su lugar)\n\n\nCódigo para modificarlo:\nuse_package()\n#’ @importFrom"
  },
  {
    "objectID": "crear_paquetes.html#someter-el-paquete-a-prueba-r-cmd-check",
    "href": "crear_paquetes.html#someter-el-paquete-a-prueba-r-cmd-check",
    "title": "Creación de paquetes",
    "section": "Someter el paquete a prueba: R CMD check",
    "text": "Someter el paquete a prueba: R CMD check\n\nPor más de que seamos cuidadosos a la hora de desarrollar nuestro paquete, hay detalles que se nos escapan, y que tarde o temprano podrían generar errores.\nPor suerte, R tiene diseñado un sistema muy exigente para identificar errores, al menos aquellos de carácter técnico.\nEste sistema se conoce como CMD Check.\nPara poder subir un paquete a CRAN, es obligatorio pasar por estos controles sin tener ningún error, nota o warning, los tres tipos de resultados que se pueden obtener.\n\n\n\n\nCRAN recibiendo nuestro paquete y evaluándolo con CMD Check\n\n\n\nAunque no queramos compartir el paquete con nadie, es útil pasar por este chequeo para asegurarnos de que ande bien.\nAdemás, tratar de solucionar los errores encontrados resulta en un gran aprendizaje sobre cuestiones de R o de programación.\nNo hay que esperar a terminar el paquete para correr CMD Check, al contrario, se sugiere hacerlo con frecuencia para ir solucionando los problemas desde temprano.\nDesde RStudio, se corre haciendo devtools::check() o con su atajo ctrl + shift + e:\n\ncheck()\n\nComo estarás observando, la salida es bastante larga, pero acá ponemos los resultados finales de la evaluación del paquete:\n\n\n\n\nResultados de check()\n\n\n\n\nSe recomienda: chequear desde temprano, chequear seguido, ponerlo a andar y mantenerlo andando.\nNota: el gold standard para controlar el paquete es correr R CMD check desde la consola, pero check() es una buena forma de hacerlo sin abandonar la sesión de RStudio. No sustituye por completo a R CMD check."
  },
  {
    "objectID": "crear_paquetes.html#establecer-una-licencia-de-uso",
    "href": "crear_paquetes.html#establecer-una-licencia-de-uso",
    "title": "Creación de paquetes",
    "section": "Establecer una licencia de uso",
    "text": "Establecer una licencia de uso\n\nComo pudimos ver recién, el control se quejó porque no establecimos todavía una licencia de uso para el paquete.\nComo los paquetes están pensados para ser distribuidos, tenemos que explicitar sí o sí qué se puede y qué no se puede hacer con el mismo.\nSi la idea es que cualquiera lo pueda usar, podemos recurrir a una de los tipos más comunes de licencia para código abierto:\n\nCC0: de dominio público, generalmente para paquetes que distribuyen datos.\nMIT: cualquiera tiene la libertad de hacer con el paquete lo que quiera.\nGPL: cambios y derivados también tienen que ser GPL.\n\nCon el paquete usethis podemos optar por cualquiera de ellas:\n\n\nusethis::use_cc0_license()\nusethis::use_mit_license()\nusethis::use_gpl_license()\n\n\nPor ejemplo:\n\n\nuse_mit_license(\"Marcos Prunello\")\n\n✔ Setting License field in DESCRIPTION to 'MIT + file LICENSE'\n✔ Writing 'LICENSE.md'\n✔ Adding '^LICENSE\\\\.md$' to '.Rbuildignore'\n✔ Writing 'LICENSE'\n\nEl DESCRIPTION fue modificado para dar cuenta de esta licencia (andá a mirarlo) y, además, se agregó un archivo LICENSE al directorio del paquete.\n\n\n\n\nResultado de emplear la licencia MIT.\n\n\n\nEl campo LICENSE en DESCRIPTION también podría usarse para establecer que el paquete no puede ser utilizado por fuera de alguna organización:\n\nLICENSE: Proprietary: do not distribute outside of Universidad Nacional de Rosario."
  },
  {
    "objectID": "crear_paquetes.html#agregar-testeos",
    "href": "crear_paquetes.html#agregar-testeos",
    "title": "Creación de paquetes",
    "section": "Agregar testeos",
    "text": "Agregar testeos\n\nSi bien anteriormente estuvimos probando el uso de nuestra función es_bisiesto(), es posible formalizar y automatizar una serie de testeos para todas las funciones del paquete.\nEsto implica expresar cuál es el comportamiento esperado de cada función frente a distintos tipos de inputs y contrastar con los resultados verdaderamente obtenidos.\nEstos controles reciben el nombre de unidades de testeo o unit tests.\nHay varios sistemas para escribir y correr unidades de testeo; acá vamos a presentar al paquete testthat, integrante del tidyverse tal como el resto de los paquetes que estamos empleando.\n\n\n\n\nPaquete testthat.\n\n\n\nPrimero corremos use_testthat(), que va a tener los siguientes efectos:\n\nAgrega testthat a Suggests en DESCRIPTION.\nCrea la carpeta tests (para alojar cualquier tipo de unidad de testeo).\nCrea la subcarpeta testthat (para alojar los testeos escritos bajo este sistema).\nCrea el archivo testthat.R (no necesitamos modificarlo, es el que dispara la ejecución de todos los testeos).\n\n\nuse_testthat()\n\n✔ Adding 'testthat' to Suggests field in DESCRIPTION\n✔ Creating 'tests/testthat/'\n✔ Writing 'tests/testthat.R'\n● Call `use_test()` to initialize a basic test file and open it for editing.\n\n\n\n\nCreación de la carpeta tests.\n\n\n\nAhora hay que escribir los testeos, los cuales se organizan en 3 niveles:\n\nArchivo de tests: uno por cada archivo .R en la carpeta R/.\nTest: conjunto de evaluaciones vinculadas por tener un tema en común. Hay varios tests por cada archivo de tests.\nExpectation: es el nivel más desagregado, corre cierto código y se compara el resultado obtenido con el esperado.\n\nLos archivos de tests van en la carpeta tests\\testthat. Sus nombres tienen que ser test-nombre_archivo_de_codigo.R.\nCreamos estos archivos a mano o con:\n\nuse_test(\"test-funciones.R\")\n\n✔ Writing 'tests/testthat/test-test-funciones.R'\n● Modify 'tests/testthat/test-test-funciones.R'\nEl archivo test-test-funciones.R se genera con un ejemplo sobre el uso de los tests:\n\n\n\n\nPlantilla para un archivo de tests.\n\n\n\nEl siguiente ejemplo muestra cómo se pueden estructurar los tests y sus expectations en este archivo:\ntest_that(\"se detectan correctamente argumentos no numéricos\", {\n  expect_error(es_bisiesto(\"hola\"), regexp = 'is.numeric(x) is not TRUE', fixed = TRUE)\n  expect_error(es_bisiesto(TRUE), regexp = 'is.numeric(x) is not TRUE', fixed = TRUE)\n})\n\ntest_that(\"se detecta correctamente años bisiestos o comunes\", {\n  expect_true(es_bisiesto(2020))\n  expect_false(es_bisiesto(2021))\n})\nUna vez escritos estos archivos, podemos evaluar los resultados de los testeos con devtools::test() o su atajo ctrl + shift + t.\nAnte cada error encontrado, nos detenemos para corregirlo y repetimos este proceso hasta que todas las unit tests pasen la prueba.\n\n\n\n\nResultado de correr los tests\n\n\n\nSi hacés nuevamente un check, vas a ver que ahora también incluye la evaluación de estos tests.\nNo es lo mismo hacer R CMD check que correr las unit tests. Lo segundo apunta a evaluar si las funciones que escribimos hacen lo que esperamos.\nR CMD check incluye a los tests, quejándose si alguno no se verifica, además de sumar toda la verificación técnica por la cual tiene que pasar un paquete.\nR CMD check es común para cualquier paquete, las unit tests son específicas para mi paquete.\nCombinando todo esto, podemos delinear un nuevo flujo de trabajo para desarrollar el paquete (le copio la figura a Hadley porque está muy linda):\n\n\n\n\nResultado de correr los tests\n\n\n\nUna medida de la calidad de un paquete está dada por el porcentaje de su código que es evaluado durante los testeos.\nEl paquete covr permite hacer ese cálculo, además de mostrar interactivamente qué partes del código fueron evaluadas y cuáles no.\n\n\n# Evaluar cobertura del archivo abierto actualmente\ndevtools::test_coverage_file()\n# Evaluar cobertura de todo el paquete\ndevtools::test_coverage()\n\n\n\n\nAnálisis de cobertura de los tests."
  },
  {
    "objectID": "crear_paquetes.html#resumen",
    "href": "crear_paquetes.html#resumen",
    "title": "Creación de paquetes",
    "section": "Resumen",
    "text": "Resumen\n\nLas siguientes funciones resumen los aspectos más importantes para crear un paquete:\n\n\nusethis::create_package()\nusethis::use_r()\ndevtools::load_all()\ndevtools::check()\ndevtools::document()\nusethis::use_test()\ndevtools::test()\ndevtools::install()"
  },
  {
    "objectID": "crear_paquetes.html#escribir-un-readme",
    "href": "crear_paquetes.html#escribir-un-readme",
    "title": "Creación de paquetes",
    "section": "Escribir un README",
    "text": "Escribir un README\n\nUn archivo README contiene información acerca de otros archivos en una carpeta.\nEs una forma de documentación de software, usualmente en un archivo de texto plano.\nEn el contexto de un paquete de R, es una muy buena práctica contar un README para describir brevemente por qué y para qué alguien tendría que usarlo, a la vez que indicar cómo conseguirlo o instalarlo.\nUna idea para estructurar el contenido de un README es:\n\nUn párrafo para describir el propósito del paquete.\nInstrucciones para su instalación, que se puedan copiar y correr en R.\nUn ejemplo de cómo se usa para resolver algo sencillo.\nLinks a las viñetas para mostrar el paquete con más detalle.\n\nComo nos pasó con otros aspectos en la construcción del paquete, podemos crear el archivo a mano o con la función usethis::use_readme_rmd():\n\n\nuse_readme_rmd()\n\n✔ Writing 'README.Rmd'\n✔ Adding '^README\\\\.Rmd$' to '.Rbuildignore'\n● Modify 'README.Rmd'\n\n\n\nPlantilla generada para crear el archivo README.\n\n\n\nEsto genera un archivo de Rmarkdown con una plantilla para que empecemos a escribir nuestro README.\nLuego, al compilarlo con knitr vamos a obtener un archivo README.md, que será la cara visible de nuestro paquete si, por ejemplo, lo subimos a GitHub donde los README vienen a tener el rol de portada en cierta forma.\n\n\n\n\nComienzo del archivo README del paquete dplyr.\n\n\n\nHay que recordar volver a compilar el README.Rmd cada vez que lo modificamos. No hay que editar a mano el README.md."
  },
  {
    "objectID": "crear_paquetes.html#escribir-el-archivo-news",
    "href": "crear_paquetes.html#escribir-el-archivo-news",
    "title": "Creación de paquetes",
    "section": "Escribir el archivo NEWS",
    "text": "Escribir el archivo NEWS\n\nMientras que el README apunta a ser leído por nuevos usuarios, el archivo NEWS es para la gente que ya usa el paquete.\nEste archivo se encarga de contar qué tenemos en cada versión nueva del paquete que publicamos: lo nuevo, lo que cambió y lo que se eliminó.\nSe sugiere usar markdown para escribir este archivo y colocar un título principal para cada versión, seguido por títulos secundarios que describen lo realizado (cambios principales, bugs arreglados, etc.).\nSi se trata de cambios impulsados por otras personas, por ejemplo, a través de sugerencias hechas en GitHub, se los menciona.\nUna buena práctica es ir escribiendo este archivo cada vez que se realiza algo nuevo en el paquete.\nLa función que nos permite crear este archivo automáticamente es usethis::use_news_md():\n\n\nuse_news_md()\n\n✔ Writing 'NEWS.md'\n● Modify 'NEWS.md'\n\n\n\nArchivo NEWS creado por default.\n\n\n\n\n\nArchivo NEWS del paquete dplyr."
  },
  {
    "objectID": "crear_paquetes.html#escribir-viñetas",
    "href": "crear_paquetes.html#escribir-viñetas",
    "title": "Creación de paquetes",
    "section": "Escribir viñetas",
    "text": "Escribir viñetas\n\nLas viñetas son un tipo especial de documentación que puede agregarse al paquete para dar más detalles y ejemplos sobre el uso del mismo.\nGeneralmente, son tutoriales que se escriben con Rmarkdown.\nSe diferencian de las páginas de ayuda en que su adición es opcional y no sigue una estructura fija, dándole la libertad al autor de enseñar de la forma que más le guste cómo usar su paquete.\nSe diferencian del archivo README porque cubren tópicos más generales, mientras que este sólo presenta una descripción breve del paquete.\nSuelen combinar texto, código, resultados, figuras, etc. En algunos casos, se convierten en verdaderos materiales de estudio.\nLos archivos .Rmd con las viñetas deben colocarse dentro de la carpeta vignettes.\nLa función usethis::use_vignette() se encarga de esto, sólo tenemos que darle como argumento el nombre de la viñeta para que nos genere un esqueleto que nos sirva de punto de partida:\n\n\nusethis::use_vignette(\"tutorial_del_paquete\")\n\n✔ Adding 'knitr' to Suggests field in DESCRIPTION\n✔ Setting VignetteBuilder field in DESCRIPTION to 'knitr'\n✔ Adding 'inst/doc' to '.gitignore'\n✔ Creating 'vignettes/'\n✔ Adding '*.html', '*.R' to 'vignettes/.gitignore'\n✔ Adding 'rmarkdown' to Suggests field in DESCRIPTION\n✔ Writing 'vignettes/tutorial_del_paquete.Rmd'\n● Modify 'vignettes/tutorial_del_paquete.Rmd'\n\n\n\nPlantilla generada para escribir la viñeta con Rmarkdown.\n\n\n\n\n\nUna de las viñetas del paquete dplyr.\n\n\nComentarios adicionales:\n\nEsta función se encarga de agregar algunas cosas en el archivo DESCRIPTION.\nSi estás haciendo control de versiones, se recomienda agregar inst/doc a .gitignore para no hacer rastreo de cambios de archivos compilados."
  },
  {
    "objectID": "crear_paquetes.html#agregar-datasets",
    "href": "crear_paquetes.html#agregar-datasets",
    "title": "Creación de paquetes",
    "section": "Agregar datasets",
    "text": "Agregar datasets\n\nEn muchos casos puede ser útil incorporar conjuntos de datos en un paquete, ya sea para que puedan usarse como ejemplos, o porque elegimos crear un paquete como un medio de distribución de datos.\nHay tres formas principales de guardar datos en un paquete\nLa ubicación más común para guardar datos es la carpeta data.\nTodos los archivos de la misma tienen que ser .Rdata (.rda), cada uno con un único objeto de R, llamado con el mismo nombre del archivo.\nPara que esto no sea confuso, se puede usar la función usethis::use_data(). Por ejemplo:\n\n\nx <- 1900:2000\ny <- runif(100)\nuse_data(x, y)\n\n✔ Saving 'x', 'y' to 'data/x.rda', 'data/y.rda'\n\n\n\nContenido de la carpeta data luego de correr use_data().\n\n\n\nSi en DESCRIPTION dejamos la opción LazyData: true, los datos no ocuparán memoria a menos que los usemos específicamente.\nSi el dataset es el resultado de algún proceso que hayamos hecho en R, se recomienda agregar el código para esto en la carpeta data-raw, para garantizar que todo sea completamente reproducible (esta carpeta se puede agregar a .Rbuidignore.).\nLos objetos en la carpeta data siempre se exportan, por lo cual hay que agregar documentación para los mismos.\nEsto se puede hacer con roxygen en cualquier Rscript de la carpeta R, aunque se acostumbra juntar toda la documentación para todos los datasets en un único archivo llamado data.R."
  },
  {
    "objectID": "crear_paquetes.html#añadir-badges",
    "href": "crear_paquetes.html#añadir-badges",
    "title": "Creación de paquetes",
    "section": "Añadir badges",
    "text": "Añadir badges\n\nLas insignias o badges son unos íconos que señalan distintas características del paquete, como su nivel de maduración, el nivel de cobertura en el testeo, cantidad de descargas, número de versión, resultado de los controles de CRAN, etc.\nSon visualmente muy atractivas y se colocan el en archivo README, como podemos ver en el ejemplo del paquete dplyr más arriba.\nEl paquete usethis trae un conjunto de funciones que generan automáticamente el código a incluir en el README.Rmd para agregar los badges:\n\n\nuse_badge(badge_name, href, src)\nuse_cran_badge()\nuse_bioc_badge()\nuse_lifecycle_badge(stage)\nuse_binder_badge(urlpath = NULL)\n\nPor ejemplo:\n\nuse_cran_badge()\n\n✔ Adding CRAN status badge to 'README.Rmd'\n● Re-knit 'README.Rmd'\n\n\n\nLíneas agregadas por use_cran_badge en README para incorporar un badge.\n\n\n\nOtra herramienta para agregar badges es el paquete badger."
  },
  {
    "objectID": "crear_paquetes.html#diseñar-un-logo",
    "href": "crear_paquetes.html#diseñar-un-logo",
    "title": "Creación de paquetes",
    "section": "Diseñar un logo",
    "text": "Diseñar un logo\n\nSeguramente has notado la costumbre de que cada paquete de R tenga su logo con forma hexagonal, que generalmente termina en forma de sticker: los hexStickers.\nBueno, para terminar de darle identidad a tu paquete y hacerlo más vistoso, podés diseñar tu logo.\nPor suerte, también hay un paquete que permite hacerlo sin demasiadas complicaciones: el paquete HexSticker.\nUna vez creado el logo, le podemos pasar su ubicación a la función use_logo(), que se encargará de darle el tamaño adecuado, guardarlo en la carpeta man del paquete y producir el código html para que lo peguemos en el README.\n\n\n\n\nHexStickers"
  },
  {
    "objectID": "crear_paquetes.html#crear-una-página-web",
    "href": "crear_paquetes.html#crear-una-página-web",
    "title": "Creación de paquetes",
    "section": "Crear una página web",
    "text": "Crear una página web\n\nSi llegaste hasta acá siguiendo todos los pasos anteriores, tenés en tu haber un montón de material muy bueno sobre tu paquete: páginas de ayuda, ejemplos, tutoriales, novedades sobre los cambios, logo, insignias, etc.\nSuficiente como para crear una página web y que tu paquete tenga presencia real en el más allá.\nNo sé cuántas veces dije “por suerte” en este material, pero lo voy a decir una vez más.\nPor suerte existe un paquete que se encarga de tomar todo el material hecho anteriormente y convertirlo en una página web AUTOMÁTICAMENTE.\nSumado a que GitHub nos da lugar para hospedar nuestras páginas de manera libre y gratuita, no hay excusas para no hacerlo.\nClaro que cuanto más quieras personalizar tu web, más vas a tener que explorar algunas opciones e incluso toquetear algo de código de html, pero esto no es necesario, ya que el aspecto logrado por default es muy satisfactorio.\nEl paquete responsable de esto es pkgdown y lo único que hay que hacer es correr pkgdown::build_site() desde el directorio de nuestro paquete cada vez que publiquemos una nueva versión.\nMás información y detalles en https://pkgdown.r-lib.org/index.html.\n\n\n\n\nLa web del paquete pkgdown, creada con pkgdown."
  },
  {
    "objectID": "crear_paquetes.html#agregar-un-git-repo",
    "href": "crear_paquetes.html#agregar-un-git-repo",
    "title": "Creación de paquetes",
    "section": "Agregar un git repo",
    "text": "Agregar un git repo\n\ngit es un sistema de control de versiones que nos permite llevar un registro de todo el código que creamos y modificamos, así como también compartirlo con otros e integrar el trabajo realizado.\nSi ya tenemos git instalado y andando en la computadora, podemos agregar un git repo con usethis::use_git()."
  },
  {
    "objectID": "crear_paquetes.html#subir-el-paquete-a-algún-repositorio",
    "href": "crear_paquetes.html#subir-el-paquete-a-algún-repositorio",
    "title": "Creación de paquetes",
    "section": "Subir el paquete a algún repositorio",
    "text": "Subir el paquete a algún repositorio\n\nCompartir un paquete que hemos creado con otras personas es muy bueno. Le da visibilidad a nuestro trabajo y también respaldo: todos pueden ver qué y cómo hacemos lo que hacemos.\nAl mismo tiempo, da la posibilidad de generar intercambios enriquecedores con otras personas que se interesen en nuestro trabajo y tengan contribuciones o comentarios para hacer.\nNo hay que olvidar, además, que un paquete puede dar lugar a una publicación.\n\n\n\n\nEnviando el paquete.\n\n\nSubirlo a GitHub\n\nComo mencionamos antes, GitHub es un repositorio que nos permite de manera muy fácil compartir con otras personas nuestros paquetes.\nSi los subimos allí, cualquiera puede instalarlos en su computadoras con install_github().\n\nSubirlo a CRAN\n\nSubir el paquete al repositorio oficial de CRAN es el toque final.\nNo vamos a entrar en detalle en esta parte, pero podés visitar los links al final de este documento para leer un poco más.\nAlgo que no hay que dejar de hacer es leer el checklist de CRAN antes de enviar el paquete, que incluye sugerencias para probar el paquete en distintos sistemas operativos.\nLas funciones de devtools que ayudan en este proceso son release() y submit_cran().\nSe puede enviar el paquete sin siquiera salir de R."
  },
  {
    "objectID": "presentacion_ropensci.html#qué-es-ropensci",
    "href": "presentacion_ropensci.html#qué-es-ropensci",
    "title": "Qué es rOpenSci",
    "section": "¿Qué es rOpenSci?",
    "text": "¿Qué es rOpenSci?\n\n\nrOpenSci = Ciencia abierta + software abierto + comunidades de práctica\nCiencia abierta. La ciencia abierta invita a quienes investigan a compartir abiertamente sus trabajos, datos y componentes de investigación para que otros puedan leerlos, reutilizarlos, reproducirlos, basarse en ellos y compartirlos.\nSoftware de código abierto. El software de código abierto es código diseñado para ser accesible al público: cualquiera puede ver, modificar y distribuir el código como mejor le parezca.\nComunidades de práctica: Grupo amplio de personas que comparten saberes y aprendizajes de un tema transversal a distintas profesiones"
  },
  {
    "objectID": "presentacion_ropensci.html#qué-hace-ropensci",
    "href": "presentacion_ropensci.html#qué-hace-ropensci",
    "title": "Qué es rOpenSci",
    "section": "¿Qué hace rOpenSci?",
    "text": "¿Qué hace rOpenSci?\n\nrOpenScie fomenta una cultura que valora la investigación abierta y reproducible utilizando datos compartidos y software reutilizable"
  },
  {
    "objectID": "presentacion_ropensci.html#cómo-lo-hace",
    "href": "presentacion_ropensci.html#cómo-lo-hace",
    "title": "Qué es rOpenSci",
    "section": "¿Cómo lo hace?",
    "text": "¿Cómo lo hace?\n\n\nCreando una infraestructura técnica de herramientas de software R cuidadosamente revisadas que reduzcan las barreras para trabajar con fuentes de datos científicos en la web.\nHaciendo que los datos, las herramientas y las mejores prácticas sean más accesibles y fáciles de encontrar.\nCreando una infraestructura social a través de una comunidad amigable y diversa.\nPromoviendo una cultura de intercambio de datos y software reutilizable.\nDesarrollando la capacidad de las personas que usan y desarrollan software y fomentando un sentimiento de orgullo por su trabajo"
  },
  {
    "objectID": "presentacion_ropensci.html#suite-de-paquetes-propios",
    "href": "presentacion_ropensci.html#suite-de-paquetes-propios",
    "title": "Qué es rOpenSci",
    "section": "Suite de paquetes propios",
    "text": "Suite de paquetes propios\nhttps://ropensci.org/packages/all/"
  },
  {
    "objectID": "presentacion_ropensci.html#revisión-de-software-por-pares",
    "href": "presentacion_ropensci.html#revisión-de-software-por-pares",
    "title": "Qué es rOpenSci",
    "section": "Revisión de software por pares",
    "text": "Revisión de software por pares\n\n\n\nProceso de revisión de paquetes R transparente, constructivo, no conflictivo, estandarizado y abierto\nMateriales para favorecer el uso de buenas prácticas y estándares\nRevisión de pares para software\nRevisión de pares para software estadístico"
  },
  {
    "objectID": "presentacion_ropensci.html#otros-proyectos",
    "href": "presentacion_ropensci.html#otros-proyectos",
    "title": "Qué es rOpenSci",
    "section": "Otros proyectos",
    "text": "Otros proyectos\n\nSistema R-Universe: Proyecto paraguas para mejorar la publicación y el descubrimiento de software de investigación en R.\nPublicaciones multilingües\nPrograma Champions: (¡enseguida les cuento más!)\nVisitar https://contributing.ropensci.org/ para ver más formas de participación."
  },
  {
    "objectID": "presentacion_ropensci.html#motivación",
    "href": "presentacion_ropensci.html#motivación",
    "title": "Qué es rOpenSci",
    "section": "Motivación",
    "text": "Motivación\n\nExiste una consternadora falta de diversidad en el ecosistema de las comunidades de software de investigación y de código abierto.\nLas personas que realizan el desarrollo de software son en general blancas, hombres y de un puñado de países.\nEsta decepcionante falta de diversidad es potencialmente perjudicial para la sostenibilidad, la utilidad y la productividad de los proyectos."
  },
  {
    "objectID": "presentacion_ropensci.html#objetivo",
    "href": "presentacion_ropensci.html#objetivo",
    "title": "Qué es rOpenSci",
    "section": "Objetivo",
    "text": "Objetivo\n\nEl programa busca apoyar a una cohorte:\n\ndiversa de personas,\nque colaboren en aspectos de la creación de software de investigación y\nque sean “líderes” de la comunidad,\ny que se esfuercen por transformar el ecosistema para mejor."
  },
  {
    "objectID": "presentacion_ropensci.html#participantes",
    "href": "presentacion_ropensci.html#participantes",
    "title": "Qué es rOpenSci",
    "section": "Participantes",
    "text": "Participantes\n\nEstá pensando para que participen personas que pertenecen a grupos histórica y sistemáticamente excluidos\nY que están interesadas en contribuir a rOpenSci y al ecosistema más amplio de comunidades de software de código abierto y de investigación."
  },
  {
    "objectID": "presentacion_ropensci.html#proyectos",
    "href": "presentacion_ropensci.html#proyectos",
    "title": "Qué es rOpenSci",
    "section": "Proyectos",
    "text": "Proyectos\n\nQuienes participan desarrollan uno de estos proyectos:\n\ncrear un nuevo paquete,\npasar por el proceso de revisión con un paquete de R que ya hayan desarrollado,\no ser un/a revisor/a del sistema de revisión por pares.\n\nal mismo tiempo que reciben capacitación… y un estipendio (USD 1000)."
  },
  {
    "objectID": "presentacion_ropensci.html#metas",
    "href": "presentacion_ropensci.html#metas",
    "title": "Qué es rOpenSci",
    "section": "Metas",
    "text": "Metas\n\n\nSe busca que quienes participen puedan:\n\nAprender y practicar la organización de talleres;\nAprender y practicar habilidades de revisión y desarrollo;\nObtener información de expertes y ampliar su red profesional;\nGanar visibilidad a través de la formación, la tutoría y la creación de contenidos;\nObtener reconocimiento y mención por su trabajo;\nCo-desarrollar este programa y otros proyectos de rOpenSci compartiendo comentarios;\nConvertirse en un/a participante activa de la comunidad rOpenSci;\nCrear contenidos en el idioma de su comunidad;\nCapacitar su comunidad compartiendo lo que aprendieron;\nConvertirse en mentor de otras personas de su comunidad."
  },
  {
    "objectID": "presentacion_ropensci.html#convocatoria-2023-abierta",
    "href": "presentacion_ropensci.html#convocatoria-2023-abierta",
    "title": "Qué es rOpenSci",
    "section": "Convocatoria 2023 abierta",
    "text": "Convocatoria 2023 abierta\nInscripción\n\n\n\n\n\n\n\n\nVolver a la página principal"
  }
]